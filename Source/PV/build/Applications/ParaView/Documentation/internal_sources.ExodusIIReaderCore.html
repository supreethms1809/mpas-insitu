
<html>
    <head>
        <title>ExodusIIReaderCore</title>
        <meta name="proxy_name" contents="internal_sources.ExodusIIReaderCore"/>
        <meta name="filename" contents="internal_sources.ExodusIIReaderCore.html"/>
    </head>
    <body>
        <h2>ExodusIIReaderCore (ExodusIIReaderCore)</h2>
        <i>
            <p>Reads an Exodus II file to produce an unstructured grid.</p>
        </i>
        <div class="description">The Exodus reader loads
                     Exodus II files and produces an unstructured grid output.
                     The default file extensions are .g, .e, .ex2, .ex2v2,
                     .exo, .gen, .exoII, .exii, .0, .00, .000, and
                     .0000.</div>
        <table width="97%" border="2px">
            <tr bgcolor="#9acd32">
                <th>Property</th>
                <th width="60%">Description</th>
                <th width="5%">Default(s)</th>
                <th width="20%">Restrictions</th>
            </tr>
            <tr>
                <th>FileName</th>
                <td>This property specifies the file name for the Exodus
        reader.</td>
                <td>
                    <span/>
                </td>
                <td>
                    <p> The value(s) must be a filename (or filenames).</p>
                </td>
            </tr>
            <tr>
                <th>HasModeShapes</th>
                <td>Some simulations overload the Exodus time steps to
        represent mode shapes. In this case, it does not make sense to iterate
        over the "time steps", because they are not meant to be played in
        order. Rather, each represents the vibration at a different "mode."
        Setting the value of this property to 1 changes the semantics of the
        reader to not report the time steps to downstream
        filters.</td>
                <td>0<span/>
                </td>
                <td>
                    <p>Accepts boolean values (0 or 1).</p>
                </td>
            </tr>
            <tr>
                <th>Animate Vibrations</th>
                <td>If this flag is on and HasModeShapes is also on, then
        this reader will report a continuous time range [0,1] and animate the
        displacements in a periodic sinusoid. If this flag is off and
        HasModeShapes is on, this reader ignores time. This flag has no effect
        if HasModeShapes is off.</td>
                <td>1<span/>
                </td>
                <td>
                    <p>Accepts boolean values (0 or 1).</p>
                </td>
            </tr>
            <tr>
                <th>TimestepValues</th>
                <td/>
                <td>
                    <span/>
                </td>
                <td/>
            </tr>
            <tr>
                <th>ModeShapesRangeInfo</th>
                <td/>
                <td>
                    <span/>
                </td>
                <td/>
            </tr>
            <tr>
                <th>ModeShape</th>
                <td>Specify which mode shape to animate when HasModeShapes
        is on.</td>
                <td>1<span/>
                </td>
                <td/>
            </tr>
            <tr>
                <th>EdgeBlocksInfo</th>
                <td/>
                <td>
                    <span/>
                </td>
                <td/>
            </tr>
            <tr>
                <th>EdgeBlocks</th>
                <td>Use this property to select which blocks of edges should
        be loaded. All edges in the same block will have the same interpolant
        (linear, quadratic, etc.) and have the same variables defined over
        them.</td>
                <td>
                    <span/>
                </td>
                <td>
                    <p>The list of array names is provided by the reader.</p>
                </td>
            </tr>
            <tr>
                <th>FaceBlocksInfo</th>
                <td/>
                <td>
                    <span/>
                </td>
                <td/>
            </tr>
            <tr>
                <th>FaceBlocks</th>
                <td>Use this property to select which blocks of faces should
        be loaded. All faces in the same block will have the same interpolant
        (triangular, bilinear quadrilateral, etc.) and have the same variables
        defined over them.</td>
                <td>
                    <span/>
                </td>
                <td>
                    <p>The list of array names is provided by the reader.</p>
                </td>
            </tr>
            <tr>
                <th>SILUpdateStamp</th>
                <td>Information property indicating the update stamp of the
        SIL. Every time the SIL is rebuilt, this time stamp is
        changed.</td>
                <td>
                    <span/>
                </td>
                <td/>
            </tr>
            <tr>
                <th>ElementBlocksInfo</th>
                <td/>
                <td>
                    <span/>
                </td>
                <td/>
            </tr>
            <tr>
                <th>SILTimeStamp</th>
                <td/>
                <td>0<span/>
                </td>
                <td/>
            </tr>
            <tr>
                <th>ElementBlocks</th>
                <td>Use this property to select which blocks of elements
        (cells) should be loaded. All elements (cells) in the same block will
        have the same interpolant (tetrahedral, triangular, trilinear
        hexahedral, etc.) and have the same variables defined over
        them.</td>
                <td>
                    <span/>
                </td>
                <td/>
            </tr>
            <tr>
                <th>GlobalVariablesInfo</th>
                <td/>
                <td>
                    <span/>
                </td>
                <td/>
            </tr>
            <tr>
                <th>GlobalVariables</th>
                <td>Use this property to select which global (i.e.,
        per-mesh) variables should be loaded. Global variables are stored as
        arrays in the field data of the reader's output.</td>
                <td>
                    <span/>
                </td>
                <td>
                    <p>The list of array names is provided by the reader.</p>
                </td>
            </tr>
            <tr>
                <th>PointVariablesInfo</th>
                <td/>
                <td>
                    <span/>
                </td>
                <td/>
            </tr>
            <tr>
                <th>PointVariables</th>
                <td>Use this property to select which nodal (i.e.,
        per-point) variables should be loaded.</td>
                <td>
                    <span/>
                </td>
                <td>
                    <p>The list of array names is provided by the reader.</p>
                </td>
            </tr>
            <tr>
                <th>EdgeVariablesInfo</th>
                <td/>
                <td>
                    <span/>
                </td>
                <td/>
            </tr>
            <tr>
                <th>EdgeVariables</th>
                <td>Use this property to select which variables defined over
        edges should be loaded. Edges are oriented boundaries of one or more
        higher-dimensional cells also present in the mesh. Edge variables
        specify a single value per entry in some edge block.</td>
                <td>
                    <span/>
                </td>
                <td>
                    <p>The list of array names is provided by the reader.</p>
                </td>
            </tr>
            <tr>
                <th>FaceVariablesInfo</th>
                <td/>
                <td>
                    <span/>
                </td>
                <td/>
            </tr>
            <tr>
                <th>FaceVariables</th>
                <td>Use this property to select which variables defined over
        faces should be loaded. Faces are oriented boundaries of one or more
        higher-dimensional cells also present in the mesh. Face variables
        specify a single value per entry in some face block.</td>
                <td>
                    <span/>
                </td>
                <td>
                    <p>The list of array names is provided by the reader.</p>
                </td>
            </tr>
            <tr>
                <th>ElementVariablesInfo</th>
                <td/>
                <td>
                    <span/>
                </td>
                <td/>
            </tr>
            <tr>
                <th>ElementVariables</th>
                <td>Use this property to select which variables defined over
        elements (cells) should be loaded. Element variables specify a single
        value per entry in some element block.</td>
                <td>
                    <span/>
                </td>
                <td>
                    <p>The list of array names is provided by the reader.</p>
                </td>
            </tr>
            <tr>
                <th>NodeMapInfo</th>
                <td/>
                <td>
                    <span/>
                </td>
                <td/>
            </tr>
            <tr>
                <th>NodeMapArrayStatus</th>
                <td>Specify which maps defined over nodes (points) in the
        mesh should be loaded. A node map is a renumbering of all the points in
        a file from their offset in the file to some arbitrary integers,
        usually specifying a unique global ID across a set of files. These are
        sometimes called new-style maps because they are specified differently
        than in older Exodus files, which only allowed a single node
        map.</td>
                <td>
                    <span/>
                </td>
                <td>
                    <p>The list of array names is provided by the reader.</p>
                </td>
            </tr>
            <tr>
                <th>EdgeMapInfo</th>
                <td/>
                <td>
                    <span/>
                </td>
                <td/>
            </tr>
            <tr>
                <th>EdgeMapArrayStatus</th>
                <td>Specify which maps defined over edges in the mesh should
        be loaded. An edge map is a renumbering of all the edges (across all
        the edge blocks of a file) from their offset in the file to some
        arbitrary integers, usually specifying a unique global ID across a set
        of files.</td>
                <td>
                    <span/>
                </td>
                <td>
                    <p>The list of array names is provided by the reader.</p>
                </td>
            </tr>
            <tr>
                <th>FaceMapInfo</th>
                <td/>
                <td>
                    <span/>
                </td>
                <td/>
            </tr>
            <tr>
                <th>FaceMapArrayStatus</th>
                <td>Specify which maps defined over faces in the mesh should
        be loaded. A face map is a renumbering of all the faces (across all the
        face blocks of a file) from their offset in the file to some arbitrary
        integers, usually specifying a unique global ID across a set of
        files.</td>
                <td>
                    <span/>
                </td>
                <td>
                    <p>The list of array names is provided by the reader.</p>
                </td>
            </tr>
            <tr>
                <th>ElementMapInfo</th>
                <td/>
                <td>
                    <span/>
                </td>
                <td/>
            </tr>
            <tr>
                <th>ElementMapArrayStatus</th>
                <td>Specify which maps defined over elements (cells) in the
        mesh should be loaded. An element map is a renumbering of all the
        elements (across all the element blocks of a file) from their offset in
        the file to some arbitrary integers, usually specifying a unique global
        ID across a set of files. These are sometimes called new-style maps
        because they are specified differently than in older Exodus files,
        which only allowed a single element map.</td>
                <td>
                    <span/>
                </td>
                <td>
                    <p>The list of array names is provided by the reader.</p>
                </td>
            </tr>
            <tr>
                <th>NodeSetInfo</th>
                <td/>
                <td>
                    <span/>
                </td>
                <td/>
            </tr>
            <tr>
                <th>NodeSetArrayStatus</th>
                <td>An Exodus II file may define subsets of all the nodes
        (points) in a file as sets in their own right. Variables, such as
        boundary conditions, may then be defined over these sets by specifying
        a single number per node. This property specifies which of those sets
        should be loaded. The accompanying NodeSetResultArrayStatus property
        specifies which variables defined over those sets should be
        loaded.</td>
                <td>
                    <span/>
                </td>
                <td>
                    <p>The list of array names is provided by the reader.</p>
                </td>
            </tr>
            <tr>
                <th>SideSetInfo</th>
                <td/>
                <td>
                    <span/>
                </td>
                <td/>
            </tr>
            <tr>
                <th>SideSetArrayStatus</th>
                <td>An Exodus II file may define subsets of all the
        boundariesof all the elements in a file as sets in their own
        right. This property specifies which of those sets should be loaded.
        Variables, such as boundary conditions, may then be defined over these
        sets by specifying a single number per side. For example, a hexahedron
        has 18 sides: 6 faces and 12 edges. Any of these sides may be
        individually called out in a set and assigned a result value. The
        accompanying SideSetResultArrayStatus property specifies which
        variables defined over those sets should be loaded.</td>
                <td>
                    <span/>
                </td>
                <td>
                    <p>The list of array names is provided by the reader.</p>
                </td>
            </tr>
            <tr>
                <th>FaceSetInfo</th>
                <td/>
                <td>
                    <span/>
                </td>
                <td/>
            </tr>
            <tr>
                <th>FaceSetArrayStatus</th>
                <td>An Exodus II file may define subsets of all the faces
        (across all face blocks) in a file as sets in their own right. This
        property specifies which of those sets should be loaded. Variables,
        such as boundary conditions, may then be defined over these sets by
        specifying a single number per face. The accompanying
        FaceSetResultArrayStatus property specifies which variables defined
        over those sets should be loaded.</td>
                <td>
                    <span/>
                </td>
                <td>
                    <p>The list of array names is provided by the reader.</p>
                </td>
            </tr>
            <tr>
                <th>EdgeSetInfo</th>
                <td/>
                <td>
                    <span/>
                </td>
                <td/>
            </tr>
            <tr>
                <th>EdgeSetArrayStatus</th>
                <td>An Exodus II file may define subsets of all the edges
        (across all edge blocks) in a file as sets in their own right. This
        property specifies which of those sets should be loaded. Variables,
        such as boundary conditions, may then be defined over these sets by
        specifying a single number per edge. The accompanying
        EdgeSetResultArrayStatus property specifies which variables defined
        over those sets should be loaded.</td>
                <td>
                    <span/>
                </td>
                <td>
                    <p>The list of array names is provided by the reader.</p>
                </td>
            </tr>
            <tr>
                <th>ElementSetInfo</th>
                <td/>
                <td>
                    <span/>
                </td>
                <td/>
            </tr>
            <tr>
                <th>ElementSetArrayStatus</th>
                <td>An Exodus II file may define subsets of all the elements
        (across all element blocks) in a file as sets in their own right. This
        property specifies which of those sets should be loaded. Variables,
        such as feature classifiers, may then be defined over these sets by
        specifying a single number per element. The accompanying
        ElementSetResultArrayStatus property specifies which variables defined
        over those sets should be loaded.</td>
                <td>
                    <span/>
                </td>
                <td>
                    <p>The list of array names is provided by the reader.</p>
                </td>
            </tr>
            <tr>
                <th>ElementSetResultArrayInfo</th>
                <td/>
                <td>
                    <span/>
                </td>
                <td/>
            </tr>
            <tr>
                <th>ElementSetResultArrayStatus</th>
                <td>An Exodus II file may define subsets of all the elements
        (across all element blocks) in a file as sets in their own right.
        Variables, such as feature classifiers, may then be defined over these
        sets by specifying a single number per element. This property specifies
        which of those variables should be loaded. The corresponding set must
        also be loaded using the ElementSetArrayStatus property in order for
        the variable to appear.</td>
                <td>
                    <span/>
                </td>
                <td>
                    <p>The list of array names is provided by the reader.</p>
                </td>
            </tr>
            <tr>
                <th>SideSetResultArrayInfo</th>
                <td/>
                <td>
                    <span/>
                </td>
                <td/>
            </tr>
            <tr>
                <th>SideSetResultArrayStatus</th>
                <td>An Exodus II file may define subsets of all the
        boundariesof all the elements in a file as sets in their own
        right. Variables, such as boundary conditions, may then be defined over
        these sets by specifying a single number per side. For example, a
        hexahedron has 18 sides: 6 faces and 12 edges. Any of these sides may
        be individually called out in a set and assigned a result value. This
        property specifies which of those variables should be loaded. The
        corresponding set must also be loaded using the SideSetArrayStatus
        property in order for the variable to appear.</td>
                <td>
                    <span/>
                </td>
                <td>
                    <p>The list of array names is provided by the reader.</p>
                </td>
            </tr>
            <tr>
                <th>FaceSetResultArrayInfo</th>
                <td/>
                <td>
                    <span/>
                </td>
                <td/>
            </tr>
            <tr>
                <th>FaceSetResultArrayStatus</th>
                <td>An Exodus II file may define subsets of all the faces
        (across all face blocks) in a file as sets in their own right.
        Variables, such as boundary conditions, may then be defined over these
        sets by specifying a single number per face. This property specifies
        which of those variables should be loaded. The corresponding set must
        also be loaded using the FaceSetArrayStatus property in order for the
        variable to appear.</td>
                <td>
                    <span/>
                </td>
                <td>
                    <p>The list of array names is provided by the reader.</p>
                </td>
            </tr>
            <tr>
                <th>EdgeSetResultArrayInfo</th>
                <td/>
                <td>
                    <span/>
                </td>
                <td/>
            </tr>
            <tr>
                <th>EdgeSetResultArrayStatus</th>
                <td>An Exodus II file may define subsets of all the edges
        (across all edge blocks) in a file as sets in their own right.
        Variables, such as boundary conditions, may then be defined over these
        sets by specifying a single number per edge. This property specifies
        which of those variables should be loaded. The corresponding set must
        also be loaded using the EdgeSetArrayStatus property in order for the
        variable to appear.</td>
                <td>
                    <span/>
                </td>
                <td>
                    <p>The list of array names is provided by the reader.</p>
                </td>
            </tr>
            <tr>
                <th>NodeSetResultArrayInfo</th>
                <td/>
                <td>
                    <span/>
                </td>
                <td/>
            </tr>
            <tr>
                <th>NodeSetResultArrayStatus</th>
                <td>An Exodus II file may define subsets of all the nodes
        (points) in a file as sets in their own right. Variables, such as
        boundary conditions, may then be defined over these sets by specifying
        a single number per node. This property specifies which of those
        variables should be loaded. The corresponding set must also be loaded
        using the NodeSetArrayStatus property in order for the variable to
        appear.</td>
                <td>
                    <span/>
                </td>
                <td>
                    <p>The list of array names is provided by the reader.</p>
                </td>
            </tr>
            <tr>
                <th>ApplyDisplacements</th>
                <td>Geometric locations can include displacements. When this
        option is on, the nodal positions are 'displaced' by the standard
        exodus displacement vector. If displacements are turned 'off', the user
        can explicitly add them by applying a warp filter.</td>
                <td>1<span/>
                </td>
                <td>
                    <p>Accepts boolean values (0 or 1).</p>
                </td>
            </tr>
            <tr>
                <th>DisplacementMagnitude</th>
                <td>When displacements are being applied, they are scaled by
        this amount. Set to 1 for no scaling.</td>
                <td>1<span/>
                </td>
                <td/>
            </tr>
            <tr>
                <th>GenerateObjectIdCellArray</th>
                <td>Specifies whether a variable named "ObjectId" should be
        created for each entry of each block and set being loaded and assigned
        the identifying number of the block or set, so that given a cell one
        can readily identify the block or set it came from. This is useful for
        coloring a mesh by block ID or set ID.</td>
                <td>1<span/>
                </td>
                <td>
                    <p>Accepts boolean values (0 or 1).</p>
                </td>
            </tr>
            <tr>
                <th>GenerateGlobalNodeIdArray</th>
                <td>Should the reader retrieve the first new-style node map,
        or if that is not present, the solitary old-style node map (which
        always exists but may be procedurally generated if it is not stored
        with the file)?</td>
                <td>1<span/>
                </td>
                <td>
                    <p>Accepts boolean values (0 or 1).</p>
                </td>
            </tr>
            <tr>
                <th>GenerateGlobalElementIdArray</th>
                <td>Should the reader retrieve the first new-style element
        map, or if that is not present, the solitary old-style element map
        (which always exists but may be procedurally generated if it is not
        stored with the file)?</td>
                <td>1<span/>
                </td>
                <td>
                    <p>Accepts boolean values (0 or 1).</p>
                </td>
            </tr>
            <tr>
                <th>GenerateImplicitNodeIdArray</th>
                <td>Should the reader retrieve the solitary old-style node
        map (which always exists but may be procedurally generated if it is not
        stored with the file)?</td>
                <td>0<span/>
                </td>
                <td>
                    <p>Accepts boolean values (0 or 1).</p>
                </td>
            </tr>
            <tr>
                <th>GenerateImplicitElementIdArray</th>
                <td>Should the reader retrieve the solitary old-style
        element map (which always exists but may be procedurally generated if
        it is not stored with the file)?</td>
                <td>0<span/>
                </td>
                <td>
                    <p>Accepts boolean values (0 or 1).</p>
                </td>
            </tr>
            <tr>
                <th>GenerateFileIdArray</th>
                <td>Should each cell in the mesh be assigned an integer
        identifying the file it came from? If turned on, a cell variable named
        "FileId" should be present.</td>
                <td>0<span/>
                </td>
                <td>
                    <p>Accepts boolean values (0 or 1).</p>
                </td>
            </tr>
            <tr>
                <th>FilePrefixInfo</th>
                <td/>
                <td>
                    <span/>
                </td>
                <td/>
            </tr>
            <tr>
                <th>FilePrefix</th>
                <td>This property specifies the file root used with the file
        pattern to format a file name. (See the File Pattern
        property).</td>
                <td>
                    <span/>
                </td>
                <td>
                    <p> The value(s) must be a filename (or filenames).</p>
                </td>
            </tr>
            <tr>
                <th>FilePatternInfo</th>
                <td/>
                <td>
                    <span/>
                </td>
                <td/>
            </tr>
            <tr>
                <th>FilePattern</th>
                <td>This property contains a text string specifying the
        pattern used to load files. There are two parts to it: the prefix (%s)
        and the file number (%i). The format used is the same as that used for
        printf.</td>
                <td>
                    <span/>
                </td>
                <td>
                    <p> The value(s) must be a filename (or filenames).</p>
                </td>
            </tr>
            <tr>
                <th>FileRangeInfo</th>
                <td/>
                <td>
                    <span/>
                </td>
                <td/>
            </tr>
            <tr>
                <th>FileRange</th>
                <td>This property controls the indices of the first and last
        files to be read.</td>
                <td>-1 -1<span/>
                </td>
                <td/>
            </tr>
            <tr>
                <th>XMLFileNameInfo</th>
                <td/>
                <td>
                    <span/>
                </td>
                <td/>
            </tr>
            <tr>
                <th>XML File Name</th>
                <td>This property specifies the name of an XML file
        containing part and material descriptions and a mapping to element
        blocks.</td>
                <td>
                    <span/>
                </td>
                <td>
                    <p> The value(s) must be a filename (or filenames).</p>
                </td>
            </tr>
        </table>
    </body>
</html>